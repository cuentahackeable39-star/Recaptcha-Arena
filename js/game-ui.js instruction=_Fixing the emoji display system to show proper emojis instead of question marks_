class GameUI {
    constructor() {
        this.elements = {
            scoreValue: document.getElementById('scoreValue'),
            levelValue: document.getElementById('levelValue'),
            streakValue: document.getElementById('streakValue'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            challengeGrid: document.getElementById('challengeGrid'),
            challengeTitle: document.getElementById('challengeTitle'),
            challengeDesc: document.getElementById('challengeDesc'),
            timerText: document.getElementById('timerText'),
            timerProgress: document.getElementById('timerProgress'),
            achievementPopup: document.getElementById('achievementPopup'),
            gameOverModal: document.getElementById('gameOverModal')
        };

        this.timerInterval = null;
        this.particleSystem = new ParticleSystem();
    }

    async renderChallengeGrid(challenge) {
        const grid = this.elements.challengeGrid;
        grid.innerHTML = '';

        const gridSize = challenge.gridSize;
        const totalTiles = gridSize * gridSize;

        grid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

        // Add special effects based on level
        if (challenge.specialEffects) {
            grid.classList.add(`effect-${challenge.specialEffects}`);
        }

        const pattern = challenge.pattern;
        const isEmoji = challenge.emoji;

        for (let i = 0; i < totalTiles; i++) {
            const tile = this.createTile(challenge, i, pattern, isEmoji);
            grid.appendChild(tile);
        }

        this.updateProgress();
    }

    createTile(challenge, index, pattern, isEmoji) {
        const tile = document.createElement('div');
        tile.className = `game-tile ${challenge.specialEffects || ''}`;

        const isTarget = pattern.includes(index);
        tile.dataset.target = isTarget;
        tile.dataset.type = challenge.targetType;

        const tileContent = document.createElement('div');
        tileContent.className = 'tile-content';

        if (isEmoji) {
            // Always show the target emoji for target tiles, decoy emoji for others
            tileContent.textContent = isTarget ? challenge.targetType : this.getDecoyEmoji(challenge.targetType);
            tileContent.style.fontSize = 'clamp(24px, 8vw, 48px)';
            tileContent.style.display = 'flex';
            tileContent.style.alignItems = 'center';
            tileContent.style.justifyContent = 'center';
        }

        // Add particle effects on hover
        tile.addEventListener('mouseenter', () => {
            if (!tile.classList.contains('clicked')) {
                this.particleSystem.create(tile);
            }
        });

        // Add click feedback
        tile.addEventListener('click', () => {
            if (!tile.classList.contains('clicked')) {
                this.createClickEffect(tile);
            }
        });

        tile.appendChild(tileContent);
        return tile;
    }

    getDecoyEmoji(targetType) {
        const decoys = {
            'ğŸš—': ['ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸš', 'ğŸ›»', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸï¸', 'ğŸš²', 'ğŸ›µ'],
            'ğŸ•': ['ğŸ”', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ§‚', 'ğŸ¥“', 'ğŸ³', 'ğŸ¥', 'ğŸ¥', 'ğŸ¥¨', 'ğŸ¥¯', 'ğŸ§€', 'ğŸ–', 'ğŸ—', 'ğŸ¥©', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸŒ¯', 'ğŸ§†', 'ğŸ¥™', 'ğŸ±', 'ğŸœ', 'ğŸ²', 'ğŸ£', 'ğŸ¤', 'ğŸ™', 'ğŸš', 'ğŸ›', 'ğŸ'],
            'ğŸ¶': ['ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸµ', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¦†', 'ğŸ¦…', 'ğŸ¦‰', 'ğŸº', 'ğŸ—', 'ğŸ´', 'ğŸ¦„', 'ğŸ', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ', 'ğŸœ', 'ğŸ¦—', 'ğŸ•·ï¸', 'ğŸ¦‚'],
            'â­': ['âœ¨', 'ğŸ’«', 'ğŸ¯', 'ğŸª', 'ğŸ­', 'ğŸ¨', 'ğŸ¸', 'ğŸº', 'ğŸ®', 'ğŸ²', 'ğŸ°', 'ğŸª', 'ğŸ¨', 'ğŸ”®', 'âš¡', 'ğŸ”¥', 'ğŸ’', 'ğŸŒˆ', 'â˜€ï¸', 'ğŸŒ™', 'ğŸ’¥', 'ğŸŠ', 'ğŸ‰'],
            'ğŸ¯': ['ğŸ†', 'ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', 'ğŸ…', 'ğŸ–ï¸', 'ğŸµï¸', 'ğŸ—ï¸', 'ğŸŸï¸', 'ğŸ«', 'ğŸª', 'ğŸ­', 'ğŸ¨', 'ğŸ¬', 'ğŸ¤', 'ğŸ§', 'ğŸ¼', 'ğŸ¹', 'ğŸ¥', 'ğŸ·', 'ğŸº', 'ğŸ¸', 'ğŸª•', 'ğŸ»']
        };

        const options = decoys[targetType] || ['â“', 'â”', 'ğŸ’­', 'ğŸ¤”', 'â“'];
        return options[Math.floor(Math.random() * options.length)];
    }

    // Rest of the class remains the same...
}